\chapter{Bitcoin}\label{ch:bitcoin}

Operating systems make it easier to develop software.
The easier it is to develop software, the more software we develop, which makes computers more useful to humans.
As a result, human society is transforming rapidly.
Two decades ago, we had to carefully plan in advance how we meet; now, we do it by mobile phone, as we go.
One decade ago, we learned what happens in the world by reading the news, which were reported by professional journalists; now, we consume social media, which is produced by ourselves.
One decade ago, we planned our holidays using travel guides and paper maps; now, we use online reviews and Google maps.
Being always connected, to your friends and to your hive, really makes a difference in how we live our lives.
What is the next big change, the next killer app?

Alas, I do not have a crystal ball.
But, I can make a few observations about the changes that did occur in the past couple of decades.
First, we can see that change happens on the timescale of about a decade.
This is quite fast if put in historical perspective: human societies used to go on for centuries before a significant change could be observed.
But, it is still slow enough that we cannot pinpoint the one moment when a change occurs.
For example, Twitter appeared in 2006.
Not many people thought that Twitter will change how a billion of people go about their lives.
Obviously, a few people did think so, but they mostly fell in two categories: those with a financial interest in Twitter's success, and those who are so enthusiastic that they think any new gadget is cool and will change the world.
Nowadays, it is undeniable that Twitter has a huge influence on daily lives.
When did Twitter go from `cute new idea that maybe will work' to `the oracle that hundreds of million people religiously consult every day'?
Hard to tell; but, sometime between 2006 and 2017.

Second, the change is usually not about a completely new idea.
Rather, it is about doing something that humans have been doing for a long time but doing it in a different way.
To take Twitter as an example again, what people do on Twitter is essentially chatting.
People have used chatting -- idle conversation about whatever crosses your mind -- for millennia.
The effect of chatting still is what it always was: sometimes it bring communities together around common ideals, other times it causes conflicts.
But, on Twitter, chatting is taken to a new level: it's not family chatting or village chatting, it's global chatting.
This quantitative difference makes a qualitative difference: chatting on Twitter \emph{feels} different.

In summary, we are looking for some widespread human habit that might change because of computers, on a timescale of $\sim10$~years.
Here's two candidates: cars and money.
So far, computers did not change in a fundamental way how we use cars; but, they threaten to replace drivers.
So far, computers did change how we use money: online commerce and credit/debit cards made us use physical money a lot less often.
But, digital money like bitcoin and ethereum threaten to bring more fundamental changes to how we use money.

This chapter will discuss how digital money works.
Before getting there, let us briefly reflect on how traditional money works.
Money is a human invention.
Initially, it solved a pragmatic problem: it reduced the complexity of the trading problem.
If Alice has onions and Bob has tomatoes, but Alice wants tomatoes and Bob wants onions, then then can meet and trade goods.
If Alice and Bob are the only characters things are simple, but then Courtney comes along the next day with potatoes.
Today, Alice still wants tomatoes, but Bob wants potatoes, and Courtney would rather have onions.
This is the OTP trading problem ({\bf o}nions, {\bf t}omatoes, {\bf p}otatoes).
To solve it, Alice, Bob and Courtney need to all get together and exchange goods.
Of course, to do this, they might first communicate their needs to each-other.
If only money had been invented!
In that case, Alice, Bob, and Courtney don't even need to know each-other.
They each go to the market and sell (for money) their surplus of vegetables.
Then, when a need arises, they go back to the market and buy (with money) what they need.
In a sense, the situation is more complicated: we need to track this thing called money, potatoes don't go directly from Courtney to Bob (but use the market as an intermediary), and the market will keep some of the vegetables in exchange for the service it provides.
But, from the point of view of each of Alice, Bob, and Courtney, the situation is vastly simpler: they just need to interact with the market, using money.
In particular, trade is just as easy in a village with 100~people as it is in a city with $10{,}000{,}000$ people.
This is what reducing trade complexity means.

Why does money work?
It has two important properties: (1)~everybody values money, and (2)~everybody trusts that everybody values money.
Why would I give my tomatoes for a piece of paper with the text $\pounds10$ written on it?
Because I trust that, in the future, other people will want that piece of paper and, in exchange, they will give me something.
If a majority of people will suddenly decide that pounds are worthless, then they \emph{will} become worthless.
We will see that digital money do not solve this problem.

The next step in the evolution of money was the apparition of banks and, more generally, of capitalism.
One characteristic of capitalism is trusting not only the value of money but also trusting the future to be better than the present.
Just like money have value only because many humans believe they have value, so capitalism works only because many humans believe in progress.
If you want to start a business, you need some money to start.
To get such money you can borrow from a bank.
If you do so, you will have to pay interest.
You will only do so if you believe that your business idea will work, and that in the future you will have more money than you have now.
Conversely, banks lend money with interest only because there exist many people willing to borrow.

Some people believe that, in the current system, banks hold too much power.
Bitcoin aims at solving this power imbalance problem.

To understand how bitcoin works, you need some background on cryptography (\autoref{sec:bitcoin-crypto}), which is why bitcoin is said to be a \emph{cryptocurrency}.
Once you understand the basics, we will look at what is a digital coin (\autoref{sec:bitcoin-coin}) and at how to keep a digital ledger of all transactions (\autoref{sec:bitcoin-ledger}).
Finally, we look at what could go wrong (\autoref{sec:bitcoin-attacks}).


\section{Cryptographic Primitives}\label{sec:bitcoin-crypto}

The two prerequisites for understanding bitcoin are (1)~public-key cryptography and (2)~cryptographic hashes.

\subsection{Public Keys}

In public-key cryptography, we rely on three operations: one that generates key pairs, and two inverse transformations on messages.
\begin{align*}
  G &: {\sf unit} \to \bigl( {\sf PrivateKey} \times {\sf PublicKey}\bigr) \\
  E &: {\sf PublicKey} \to {\sf Message} \to {\sf Message} \\
  D &: {\sf PrivateKey} \to {\sf Message} \to {\sf Message}
\end{align*}
Suppose we call $G()$ and we get back the pair $({\it pri},{\it pub})$, where $\it pri$ is the private key and ${\it pub}$ is the public key.
We assume that it is difficult to discover ${\it pri}$ if you know ${\it pub}$.
We will see later that there are some good reasons behind this assumption, but it is not a certainty.
If we give $E$ a public key, then it becomes a function of the type ${\sf Message} \to {\sf Message}$, which transforms messages;
similarly, if we give $D$ a private key, then it becomes a function which transforms messages.
If $({\it pri}, {\it pub})$ come from the same call to $G$, then we should have that $E\,{\it pub}$ and $D\,{\it pri}$ are inverses:
\begin{align*}
  E\,{\it pub} \circ D\,{\it pri}
  = D\,{\it pri} \circ E\,{\it pub}
  = {\tt id}
\end{align*}

The two common use-cases are \emph{encrypting} and \emph{signing} messages.
Suppose that each person has a key pair.
Let us write ${\it pri}_x$ for the private key of~$x$, and ${\it pub}$ for the public key of~$x$.
The public keys are known by everyone; the private key ${\it pri}$ is known only to~$x$.
Suppose now that Alice wants to send a message to Bob, but she wants to make sure that Courtney and other people cannot read it.
What should she do?
If Alice wants to say~$m$, she sends $E\,{\it pub}_{\rm Bob}\,m$ to Bob, and tells him the message is encrypted.
Bob then computes $D\,{\it pri}_{\rm Bob}\,(E\,{\it pub}_{\rm Bob}\,m)$, which equals~$m$.
For this computation, Bob's private key is required, so nobody else could do it.

Now consider a different scenario.
Alice wants to send message~$m$ to Bob.
This time she does not care if somebody else reads the message.
She wants, however, to make sure that Bob knows the message is from her.
In this situation, she sends $D\,{\it pri}_{\rm Alice}\,m$, and then Bob computes $E\,{\it pub}_{\rm Alice}\,(D\,{\it pri}_{\rm Alice}\,m)=m$.

OK, we saw some example uses of the functions $E$~and~$D$.
But, why do we believe that such functions exists?
One example is the basic RSA scheme, which works as follows:
\medskip
\begin{alg}
\^  $G()$
\0  let $p$ and $q$ be two distinct prime numbers, chosen randomly
\0  let $e$ and $d$ be two integers such that $ed = 1 \pmod{(p-1)(q-1)}$
\0  return $\bigl((pq,d),\, (pq,e)\bigr)$
\end{alg}
\medskip
\noindent
And we let both $E\,(n,b)\,a$ and $D\,(n,b)\,a$ to be $a^b \bmod n$.
We can now check that $E\,(pq,e)$ and $D\,(pq,d)$ are inverses.
\begin{align*}
E\,(pq,e)\,\bigl(D\,(pq,d)\,m\bigr)
  = E\,(pq,e)\,\bigl(m^d \bmod pq\bigr)
  = \bigl(m^d \bmod pq\bigr)^e \bmod pq
  = m^{ed} \bmod pq
\end{align*}
We want to show that $m^{ed}\equiv m \pmod{pq}$ for all~$m$.
By the Chinese Reminder Theorem, we need to show that $m^{ed} \equiv m \pmod{p}$ and $m^{ed} \equiv m \pmod{q}$.
These are clearly true for $m=0$.
For $m>0$, Fermat's Little Theorem says that $m^{p-1} \equiv 1 \pmod{p}$.
Since $ed-1 \equiv 0 \pmod{(p-1)(q-1)}$, we have that $m^{ed-1}=m^{(p-1)k}$ for some~$k$.
Thus,
\begin{align*}
m^{ed} \equiv m \cdot m^{ed-1} \equiv m \cdot \bigl(m^{p-1}\bigr)^k \equiv m
  \pmod{p}
\end{align*}
The case for $q$ is similar.

RSA rests on the following facts about what is hard and what is easy to compute:
(1)~We know how to generate big random prime numbers (and often we even settle for numbers which are primes with high probability);
(2)~If we know both $p$ and $q$, then we know how to efficiently invert a number modulo $(p-1)(q-1)$ (see Exercises);
(3)~If we know $pq$, we do not know how compute $p$ and $q$ efficiently.


\subsection{Hashing}\label{sec:bitcoin-hash}

The signing scheme we saw in the previous section is somewhat awkward.
You would expect a signature to be a short note you append to the message.
We can make digital signatures resemble more the real signatures by using hashing.
A \df{hash} function is a function $h:A\to B$ such that $A$ has more elements than~$B$.
For concreteness, let us fix the domain~$A$ to be the set $\{0,1\}^*$ of all bitstrings, and the co-domain~$B$ to be the set $\{0,1\}^{256}$ of bitstrings with length exactly~$256$.
Since there are more bitstrings than there are bitstrings of length~$256$, it must be that there exist different bitstrings with the same hash: $x\ne y$ and $h(x)=h(y)$, for some $x,y\in\{0,1\}^*$.
Such a situation is called a \df{collision}.
A \df{cryptographic hash} function is a hash function for which it is difficult to find collisions.
More precisely, cryptographic hash functions come in families $\bigl\{h_s \mid s\in\{0,1\}^*\bigr\}$ indexed by bitstrings~$s$; that is, you tell me a bitstring~$s$ and I give you a particular hash function~$h_s$.
We now consider algorithms that input~$s$ and output a pair $(x,y)$ that witnesses a collision of $h_s$.
We allow these algorithms to use randomness (that is, they can throw coins), but we give then only a polynomial amount of time (that is, they need to meet some baseline of efficiency).
If each such algorithm gets it right only with negligible chance (they might get it right if the coins turn out just right!), then we say that the hash $h$~is cryptographic.

If it is hard to find collisions, then the following two tasks are also hard:
\begin{enumerate}
\item[(a)] Given $s$ and $x$, find $y$ such that $h_s(x)=h_s(y)$ and $x\ne y$.
\item[(b)] Given $s$ and $b$, find $y$ such that $b=h_s(y)$.
\end{enumerate}
For example, let us show that an efficient solution to~(a) implies an efficient way of finding collisions.
Assume we can solve~(a) efficiently.
Then we find collisions as follows: pick a random~$x$ and then solve~(a).

\medskip

How do we use cryptographic hashing to sign messages?
Let us get back to the scenario in which Alice wants to say~$m$ to Bob, and she wants Bob to know that the message is from her.
Previously, we saw that she could send $D\,{\it pri}_{\rm Alice}\,m$.
Instead, this time she computes $h_s(m)$ (for some fixed, known~$s$), and only uses her private key on this hash.
She sends Bob the original message~$m$, followed by $D\,{\it pri}_{\rm Alice}\,\bigl(h_s(m)\bigr)$.
When Bob receives these two pieces of information, he does two things:
\begin{itemize}
\item re-hash the message $m$ with the known $h_s$, and
\item apply $E\,{\it pub}_{\rm Alice}$ to the signature:
  $E\,{\it pub}_{\rm Alice}\,\bigl(D\,{\it pri}_{\rm Alice}\,\bigl(h_s(m)\bigr)\bigr)$
\end{itemize}
Finally, Bob simply checks if the two steps from above give the same result.


\section{Coins}\label{sec:bitcoin-coin}

We now have all the ingredients necessary to understand how digital (bit)coins work.
A coin is a sequence of transactions:
\begin{align*}
  \ldots,
  T_{AB},
  T_{BC},
  T_{CD}
\end{align*}
We will see later how this sequence starts.
In transaction $T_{xy}$, the coin changes hands from~$x$ to~$y$.
We say that $x$~is the \df{former owner} and $y$ is the \df{new owner}.
Consider two consecutive transactions $T_{xy},T_{yz}$, and let us see what information goes into $T_{yz}$:
\begin{itemize}
\item a pointer to the previous transaction $T_{xy}$
  (If you think of transactions as being stored in files, then this would be the filename where transaction $T_{xy}$ is stored);
\item a public key of the new owner: ${\it pub}_z$;
\item a signature created by the old owner:
  $D\,({\it pri}_y)\,\bigl(h(T_{xy}\cdot{\it pub}_z)\bigr)$
\end{itemize}
\todo{how created}

Given two transactions $T_{xy},T_{yz}$ anybody can check that they are correct.
More precisely, anybody can check that the person who claims to give the coin in transaction $T_{yz}$ is the person who was given the coin in transaction $T_{xy}$.
How?
By looking at $T_{xy}$, we find ${\it pub}_y$, which is the public key of the person receiving the coin in transaction $T_{xy}$.
Now we look at transaction $T_{yz}$ and extract from there the signature ${\it sig}$, which is supposed to be $D\,{\it pri}_y\,\bigl(h_s(T_{xy}\cdot{\it pub}_z)\bigr)$.
We check whether this is indeed the case.
First, we compute $E\,{\it pub}_y\,{\it sig}$.
The result should be $h_s(T_{xy}\cdot{\it pub}_z)$.
We check this by recomputing this hash, which we can do because we have both $T_{xy}$ and ${\it pub}_z$ (from $T_{yz}$).


\section{Ledger}\label{sec:bitcoin-ledger}

As we saw, anyone can verify that a coin is spent only by someone who was previously given that coin.
However, anyone who was given a coin can spend it not just once but multiple times.
We need a mechanism to make sure that such double-spending does not happen.


\section{Attacks}\label{sec:bitcoin-attacks}

\section{Exercises}

\begin{enumerate}
\item
  $\blacktriangleright$
  Suppose Alice wants to send a secret message to Bob, and she wants to sign the message.
  How can she do it?

\item
  \todo{Implement this.}
  For RSA, step~2 of key generation is not easy.
  Look up how to do it; for example, in Wikipedia.

\item
  $\blacktriangleright$
  In the RSA scheme, suppose $p=13$ and $q=7$.
  (These prime numbers numbers are of course too small to make the scheme secure.)
  Further, pick $e=5$ and $d=29$.
  What are the corresponding public and private keys?
  What do we get if we encrypt $m=2$?
  What do we get if we decrypt $m=2$?

\item
  $\blacktriangleright$
  In~\autoref{sec:bitcoin-hash} we saw two problems, (a)~and~(b).
  Show that (a)~is at least as hard as~(b).

\item
  $\blacktriangleright$
  Consider the signature scheme with hashing (\autoref{sec:bitcoin-hash}).
  What could go wrong if Alice and Bob use a hashing function which is not cryptographic?
\end{enumerate}

\section{Notes}

For more historical information on money, I recommend Chapters 10~and~16 of \citet{sapiens}, and the YouTube videos that accompany the book.
If you want to learn more about Bitcoin, see the original article \citep{bitcoin}, which is clear and lucid.



% vim:spell:spelllang=en_gb:

